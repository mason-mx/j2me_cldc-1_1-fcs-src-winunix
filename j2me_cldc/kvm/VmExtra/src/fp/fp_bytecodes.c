/*
 * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 */

#include <global.h>

/*
 * The techniques described below are also documented in the Java
 * GrandeNumerics Working Group report "Improving Java for Numerical
 * Computation:"
 * http://math.nist.gov/javanumerics/reports/jgfnwg-01.html
 *
 *  What is the problem?
 * ---------------------
 *
 * Briefly, the x86 is designed to operate on 80-bit double extended
 * floating-point values rather than the 64 bit and 32 bit double and
 * float values used in Java.  The x86 can be made to round to float or
 * double precision; unfortunately, this doesn't exactly emulate the pure
 * float and double called for by Java since an extended exponent range
 * is available.  The extended exponent range means the overflow and
 * underflow thresholds are different than for pure float and double.  A
 * store to memory will round a floating-point value, possibly with an
 * extended exponent, to pure float or double.  A load is then necessary
 * to get the value back into the floating-point registers for further
 * computation.  Therefore, the basic idiom for strictfp arithmetic on
 * the x86 is:
 *
 * load arg1
 * load arg2
 * fp-op on arg1 and arg2
 * store calculated fp-op result
 * reload stored result
 *
 * This idiom implements strictfp semantics for float and double addition
 * and subtraction.  However, this idiom is *not* sufficient to implement
 * strictfp semantics for double multiply and divide.  (If the rounding
 * precision is set to double, this idiom *does* work for float multiply
 * and divide since there is enough additional precision to avoid the
 * double rounding problem discussed below.)  The above idiom will
 * enforce the proper overflow threshold for double multiply and divide
 * but the underflow threshold will not be emulated properly.
 * Essentially, what is a subnormal result in pure double is first
 * rounded once to full precision (because of the extended exponent
 * range) and then rounded a second time to reduced precision when
 * constrained to the pure double exponent range.  (Subnormal numbers are
 * very small IEEE 754 values with less precision than normal numbers.)
 * This double rounding can give a different result than a single
 * rounding to a pure double subnormal.  To address this latter
 * discrepancy, a refinement of the store-reload idiom that includes
 * scaling must be used.
 *
 * The essence of the refined technique is to arrange so that what would
 * be subnormal result in pure double is calculated as a subnormal result
 * in double with extended exponent range.  This ensures all the
 * significand bits are correct.  The exponent bits are then corrected by
 * rescaling.  The scaling factor needed is a power of 2 equal to the
 * difference in maximum exponents between double extended and pure
 * double.  It is significantly faster to perform the scaling with
 * multiplies rather than divides; therefore, scaling factors with both
 * positive and negative exponents are desirable.
 *
 * Constants needed for the scaling/rescaling are
 *
 * 2^(Emax double extended - Emax double)
 *
 * and
 *
 * 2^-(Emax double extended - Emax double)
 *
 * which are equal to
 *
 * 2^(16383 - 1023) = 2^15360
 *
 * and
 *
 * 2^(16383 - 1023) = 2^-15360
 *
 * respectively.  The scaling factors are outside the range of numbers
 * that can be represented as a double.  However, they can be easily
 * generated by starting with a representable double value:
 *
 * 2^15360 ==  ((((2^960 )^2)^2)^2)^2
 * 2^-15360 == ((((2^-960)^2)^2)^2)^2
 *
 * 2^960 == 9.745314011399999E288 == longBitsToDouble(0x7bf0000000000000)
 *
 * 2^-960 = 1.0261342003245941E-289 == longBitsToDouble(0x3f0000000000000)
 *
 * d = // 2^960 or 2^(-960)
 * for(int i = 0; i < 4; i++)
 *   d *= d;
 *
 * After the double extended value is generated, The final bit patterns,
 * from most to least significant bit, are:
 *
 * 2^15360: 0x7bff 8000 0000 0000 0000
 * 2^(-15360)   0x03ff 8000 0000 0000 0000
 *
 * A few comments on why these bits are correct; the intel double
 * extended format has a 64 bit significand, a 15 bit exponent, and one
 * sign bit.  The significand is the low-order 64 bits, the sign and
 * exponent the high-oder 16 bits. Unlike other IEEE 754 formats, the
 * double extended format has an explicit "implicit bit;" since
 * floating-point numbers are normalized storing the leading bit is not
 * necessary since it is implied by the exponent value and therefore left
 * implicit in the float and double formats.  Having this bit explicit
 * leads to the "8" in the constants above.  The exponent is encoded in
 * excess 16383 format; that is, to get the encoding, take the true
 *
 * exponent value, add 16383 and store as an unsigned 15 bit value.
 *
 * Correct strictfp double multiply and divide idioms
 * ----------------------------------------------------
 * These techniques are branch free are require no special code for NaN,
 * infinities, or zeros.
 *
 * Multiply
 * ---------------
 * load arg1
 * scale arg1 by multiplying arg1 by 2^(-15360)
 * load arg2
 * multiply scaled arg1 by arg2
 * rescale product by 2^(15360)
 * store rescaled product
 * reload stored rescaled product
 *
 *
 * Divide
 * ---------------
 * load dividend
 * scale dividend by multiplying dividend by 2^(-15360)
 * load divisor
 * divide scaled dividend by divisor
 * rescale quotient by 2^(15360)
 * store rescaled quotient
 * reload stored rescaled quotient
 */

#if PROCESSOR_ARCHITECTURE_X86

/*
 * Implementation note: The functions below have been designed
 * to be called directly from the interpreter.  Instead of
 * returning using C return values, these functions store
 * the return values directly into the KVM operand stack.
 */

void JFP_lib_dmul_x86(double lvalue, double rvalue) {
    double pos_d = 9.745314011399999E288;
    double neg_d = 1/pos_d;

    long double value;
    value = (((neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d *
               neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d) * lvalue) * rvalue) *
              (pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d *
               pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d);

    SET_DOUBLE(getSP() - 3, value);
}

void JFP_lib_ddiv_x86(double lvalue, double rvalue) {
    double pos_d = 9.745314011399999E288;
    double neg_d = 1/pos_d;

    long double value;
    value = (((neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d *
               neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d) * lvalue) / rvalue) *
              (pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d *
               pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d);

    SET_DOUBLE(getSP() - 3, value);
}

void JFP_lib_fcmpl_x86(float lvalue, float rvalue) {
    long  rrawbits = *(long *)&rvalue;
    long  lrawbits = *(long *)&lvalue;

    if (((lrawbits >= F_L_POS_NAN) && (lrawbits <= F_H_POS_NAN)) ||
        ((lrawbits >= F_L_NEG_NAN) && (lrawbits <= F_H_NEG_NAN)) ||
        ((rrawbits >= F_L_POS_NAN) && (rrawbits <= F_H_POS_NAN)) ||
        ((rrawbits >= F_L_NEG_NAN) && (rrawbits <= F_H_NEG_NAN))) {
        *(long *)getSP() = -1;
    } else {
        *(long*)getSP() = (lvalue >  rvalue) ?  1 :
                          (lvalue == rvalue) ?  0 : -1;
    }
}

void JFP_lib_fcmpg_x86(float lvalue, float rvalue) {
    long  rrawbits = *(long *)&rvalue;
    long  lrawbits = *(long *)&lvalue;

    if (((lrawbits >= F_L_POS_NAN) && (lrawbits <= F_H_POS_NAN)) ||
        ((lrawbits >= F_L_NEG_NAN) && (lrawbits <= F_H_NEG_NAN)) ||
        ((rrawbits >= F_L_POS_NAN) && (rrawbits <= F_H_POS_NAN)) ||
        ((rrawbits >= F_L_NEG_NAN) && (rrawbits <= F_H_NEG_NAN))) {
        *(long *)getSP() = 1;
    } else {
        *(long*)getSP() = (lvalue >  rvalue) ?  1 :
                          (lvalue == rvalue) ?  0 :
                          (lvalue <  rvalue) ? -1 : 1;
    }
}

void JFP_lib_dcmpl_x86(double lvalue, double rvalue) {
    long64 rrawbits = *(long64 *)&rvalue;
    long64 lrawbits = *(long64 *)&lvalue;

    if (((lrawbits >= D_L_POS_NAN) && (lrawbits <= D_H_POS_NAN)) ||
        ((lrawbits >= D_L_NEG_NAN) && (lrawbits <= D_H_NEG_NAN)) ||
        ((rrawbits >= D_L_POS_NAN) && (rrawbits <= D_H_POS_NAN)) ||
        ((rrawbits >= D_L_NEG_NAN) && (rrawbits <= D_H_NEG_NAN))) {
        *(long*)getSP() = -1;
    } else {
        *(long*)getSP() = (lvalue >  rvalue) ?  1 :
                          (lvalue == rvalue) ?  0 : -1;
    }
}

void JFP_lib_dcmpg_x86(double lvalue, double rvalue) {
    long64 rrawbits = *(long64 *)&rvalue;
    long64 lrawbits = *(long64 *)&lvalue;

    if (((lrawbits >= D_L_POS_NAN) && (lrawbits <= D_H_POS_NAN)) ||
        ((lrawbits >= D_L_NEG_NAN) && (lrawbits <= D_H_NEG_NAN)) ||
        ((rrawbits >= D_L_POS_NAN) && (rrawbits <= D_H_POS_NAN)) ||
        ((rrawbits >= D_L_NEG_NAN) && (rrawbits <= D_H_NEG_NAN))) {
        *(long*)getSP() = 1;
    } else {
        *(long*)getSP() = (lvalue >  rvalue) ?  1 :
                          (lvalue == rvalue) ?  0 :
                          (lvalue <  rvalue) ? -1 : 1;
    }
}

void JFP_lib_frem_x86(float lvalue, float rvalue) {
    float result;
    long  rrawbits = *(long *)&rvalue;
    long  lrawbits = *(long *)&lvalue;

    if (((rrawbits == F_POS_INFINITY) || (rrawbits == F_NEG_INFINITY)) &&
        ((lrawbits & 0x7FFFFFFF) < F_POS_INFINITY)) {
        *(float *)getSP() = lvalue;
    } else {
        result = (float)DOUBLE_REMAINDER(lvalue, rvalue);
        /* Retrieve the sign bit to find +/- 0.0 */
        if ((lrawbits & 0x80000000) == 0x80000000) {
            if ((*(long *)&result & 0x80000000) != 0x80000000) {
                result *= -1;
            }
        }
        *(float *)getSP() = result;
    }
}

void JFP_lib_drem_x86(double lvalue, double rvalue) {
    double result;
    long64 rrawbits = *(long64 *)&rvalue;
    long64 lrawbits = *(long64 *)&lvalue;

    if (((rrawbits == D_POS_INFINITY) || (rrawbits == D_NEG_INFINITY)) &&
        ((lrawbits & 0x7FFFFFFFFFFFFFFFL) < D_POS_INFINITY)) {
        SET_DOUBLE(getSP() - 3, lvalue);
    } else {
        result = DOUBLE_REMAINDER(lvalue, rvalue);
        /* Retrieve the sign bit to find +/- 0.0 */
        if ((lrawbits & 0x8000000000000000L) == 0x8000000000000000L) {
            if ((*(long64 *)&result & 0x8000000000000000L) != 0x8000000000000000L) {
                result *= -1;
            }
        }
        SET_DOUBLE(getSP() - 3, result);
    }
}

#endif /* PROCESSOR_ARCHITECTURE_X86 */

